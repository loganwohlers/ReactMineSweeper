{"ast":null,"code":"var _jsxFileName = \"/Users/clairemuller/Dev/ReactMineSweeper/src/containers/GameBoard.js\";\nimport React from 'react';\nimport Square from '../components/Square';\nimport GameInfoBar from '../components/GameInfoBar';\nimport NewGameMenu from '../components/NewGameMenu';\n\nclass GameBoard extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.determineBoard = difficulty => {\n      let newGrid, mines;\n\n      if (difficulty === \"intermediate\") {\n        newGrid = Array(16).fill().map(() => new Array(16).fill(0));\n        mines = 40;\n      } else if (difficulty === \"difficult\") {\n        newGrid = Array(22).fill().map(() => new Array(22).fill(0));\n        mines = 99;\n      } else {\n        newGrid = Array(9).fill().map(() => new Array(9).fill(0));\n        mines = 10;\n      }\n\n      this.setState({\n        grid: newGrid,\n        mines\n      }, () => {\n        this.randomMines();\n      });\n    };\n\n    this.handleSquareClick = coords => {\n      if (this.state.active) {\n        let currentValue = this.state.grid[coords[0]][coords[1]]; // bomb click\n\n        if (currentValue === 'b') {\n          this.setState({\n            dead: true,\n            active: false\n          }); // empty square click\n        } else if (currentValue === 0) {\n          this.handleZeroSquareClick(coords); // number square click\n        } else {\n          let copyGrid = [...this.state.grid];\n          copyGrid[coords[0]][coords[1]] = currentValue + \"*\";\n          this.setState({\n            grid: copyGrid\n          });\n        }\n\n        if (this.state.mines === 0) {\n          this.winCheck();\n        }\n      }\n    };\n\n    this.handleZeroSquareClick = coords => {\n      let copyGrid = [...this.state.grid];\n      let visited = {};\n      visited[coords] = true;\n      let queue = [coords];\n\n      while (queue.length > 0) {\n        let current = queue.pop();\n\n        if (copyGrid[current[0]][current[1]] === 0) {\n          // grid shows first character - need blank space\n          copyGrid[current[0]][current[1]] = ' *';\n        } //grab all possibile neighboring tiles\n\n\n        let poss = this.generatePossibilities(current[0], current[1]); // filter possibilities for number tile and reveal them\n\n        let neighborNums = poss.filter(n => copyGrid[n[0]][n[1]] !== 0);\n        neighborNums.forEach(ss => {\n          let currValue = copyGrid[ss[0]][ss[1]]; // * is revealed\n\n          copyGrid[ss[0]][ss[1]] = currValue + \"*\";\n        }); //filter for suitable 0/blank tiles and visit them on search\n\n        let neighborBlanks = poss.filter(n => copyGrid[n[0]][n[1]] === 0);\n\n        for (let i = 0; i < neighborBlanks.length; i++) {\n          if (!visited[neighborBlanks[i]]) {\n            queue.push(neighborBlanks[i]);\n            visited[neighborBlanks[i]] = true;\n          }\n        }\n      }\n\n      this.setState({\n        grid: copyGrid\n      });\n    };\n\n    this.handleFlagClick = (e, coords) => {\n      if (this.state.active) {\n        let mines = this.state.mines;\n        let copyGrid = [...this.state.grid];\n        let stringValue = copyGrid[coords[0]][coords[1]] + ''; //remove flag\n\n        if (stringValue.includes('F')) {\n          mines++;\n          copyGrid[coords[0]][coords[1]] = stringValue.slice(0, 1); //adding flag\n        } else {\n          mines--;\n          copyGrid[coords[0]][coords[1]] += 'F';\n        }\n\n        this.setState({\n          grid: copyGrid,\n          mines\n        }, () => this.winCheck());\n      }\n    };\n\n    this.winCheck = () => {\n      if (this.state.mines === 0) {\n        for (let i = 0; i < this.state.grid.length; i++) {\n          for (let j = 0; j < this.state.grid.length; j++) {\n            let currValue = this.state.grid[i][j] + '';\n            console.log(currValue);\n\n            if (!(currValue.includes('*') || currValue === 'bF')) {\n              return false;\n            }\n          }\n        }\n\n        this.setState({\n          active: false\n        });\n        return true;\n      }\n    };\n\n    this.gameStarted = () => {\n      if (!this.state.dead && !this.state.active) {\n        this.setState({\n          active: true\n        });\n      }\n    };\n\n    this.restartGame = difficulty => {\n      this.setState({\n        dead: false,\n        active: false\n      }, () => {\n        this.determineBoard(difficulty);\n      }); //reset timer\n    };\n\n    this.state = {\n      grid: [],\n      mines: 0,\n      dead: false,\n      active: false\n    };\n  }\n\n  componentDidMount() {\n    this.determineBoard(this.props.difficulty);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.difficulty !== this.props.difficulty && this.state.active === false) {\n      this.determineBoard(this.props.difficulty);\n    }\n  }\n\n  randomMines() {\n    let mines = 0;\n    let copyGrid = [...this.state.grid];\n\n    while (mines < this.state.mines) {\n      let x = Math.floor(Math.random() * this.state.grid.length);\n      let y = Math.floor(Math.random() * this.state.grid.length);\n\n      if (copyGrid[x][y] === 0) {\n        copyGrid[x][y] = 'b';\n        mines++;\n      }\n    }\n\n    this.setState({\n      grid: copyGrid\n    }, () => this.setNeighborCount());\n  } //reassigns the values in the state grid to accuratly reflect the number of mines contained in neighboring tiles\n\n\n  setNeighborCount() {\n    let copyGrid = [...this.state.grid];\n\n    for (var i = 0; i < copyGrid.length; i++) {\n      for (var j = 0; j < copyGrid.length; j++) {\n        if (copyGrid[i][j] !== 'b') {\n          copyGrid[i][j] = this.neighborMines(i, j, copyGrid);\n        }\n      }\n    }\n\n    this.setState({\n      grid: copyGrid\n    });\n  } //checks- through a copy of the current state grid- the value of all neighboring tiles and returns # of mines\n\n\n  neighborMines(x, y, copyGrid) {\n    let bombCount = 0;\n    let poss = this.generatePossibilities(x, y);\n\n    for (var i = 0; i < poss.length; i++) {\n      let xx = poss[i][0];\n      let yy = poss[i][1];\n      let coords = copyGrid[xx][yy];\n\n      if (coords === 'b') {\n        bombCount++;\n      }\n    }\n\n    return bombCount;\n  } //uses a 2d array of the 8 possible tiles around any given x,y coordinate and\n  //then filters out those which could not exist on currents state's board length\n\n\n  generatePossibilities(x, y) {\n    let all = [[x - 1, y - 1], [x - 1, y], [x - 1, y + 1], [x, y + 1], [x, y - 1], [x + 1, y - 1], [x + 1, y], [x + 1, y + 1]];\n    return all.filter((coords, i) => {\n      let xx = all[i][0];\n      let yy = all[i][1];\n      return xx >= 0 && yy >= 0 && xx < this.state.grid.length && yy < this.state.grid.length;\n    });\n  } //breadth first search to \"click\" all suitable 0 tiles and reveal all suitable # tiles\n\n\n  render() {\n    //render the current board via passing in values from state grid to Square components and\n    //arranging them in a table\n    const gameGrid = this.state.grid.map((row, i) => {\n      return React.createElement(\"tr\", {\n        key: \"row\" + i,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 240\n        },\n        __self: this\n      }, row.map((col, j) => {\n        let revealed = false;\n        let flagged = false;\n        let currentValue = this.state.grid[i][j].toString();\n        currentValue.includes('*') ? revealed = true : revealed = false;\n        currentValue.includes('F') ? flagged = true : flagged = false;\n        return React.createElement(Square, {\n          key: i + \":\" + j,\n          revealed: revealed,\n          data: currentValue.charAt(0),\n          flagged: flagged,\n          dead: this.state.dead,\n          coords: [i, j],\n          handleSquareClick: this.handleSquareClick,\n          handleFlagClick: this.handleFlagClick,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 248\n          },\n          __self: this\n        });\n      }));\n    });\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 264\n      },\n      __self: this\n    }, React.createElement(GameInfoBar, {\n      mines: this.state.mines,\n      active: this.state.active,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 265\n      },\n      __self: this\n    }), React.createElement(\"table\", {\n      cellSpacing: \"0\",\n      id: \"table\",\n      onMouseEnter: this.gameStarted,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 268\n      },\n      __self: this\n    }, React.createElement(\"tbody\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 269\n      },\n      __self: this\n    }, gameGrid)), this.state.dead || this.winCheck() ? React.createElement(NewGameMenu, {\n      difficulty: this.state.difficulty,\n      restart: this.restartGame,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 274\n      },\n      __self: this\n    }) : null);\n  }\n\n}\n\nexport default GameBoard;","map":{"version":3,"sources":["/Users/clairemuller/Dev/ReactMineSweeper/src/containers/GameBoard.js"],"names":["React","Square","GameInfoBar","NewGameMenu","GameBoard","Component","constructor","props","determineBoard","difficulty","newGrid","mines","Array","fill","map","setState","grid","randomMines","handleSquareClick","coords","state","active","currentValue","dead","handleZeroSquareClick","copyGrid","winCheck","visited","queue","length","current","pop","poss","generatePossibilities","neighborNums","filter","n","forEach","ss","currValue","neighborBlanks","i","push","handleFlagClick","e","stringValue","includes","slice","j","console","log","gameStarted","restartGame","componentDidMount","componentDidUpdate","prevProps","x","Math","floor","random","y","setNeighborCount","neighborMines","bombCount","xx","yy","all","render","gameGrid","row","col","revealed","flagged","toString","charAt"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,MAAP,MAAmB,sBAAnB;AACA,OAAOC,WAAP,MAAwB,2BAAxB;AACA,OAAOC,WAAP,MAAwB,2BAAxB;;AAEA,MAAMC,SAAN,SAAwBJ,KAAK,CAACK,SAA9B,CAAwC;AACtCC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;;AADiB,SAoBnBC,cApBmB,GAoBDC,UAAD,IAAgB;AAC/B,UAAIC,OAAJ,EAAaC,KAAb;;AACA,UAAIF,UAAU,KAAK,cAAnB,EAAmC;AACjCC,QAAAA,OAAO,GAAGE,KAAK,CAAC,EAAD,CAAL,CAAUC,IAAV,GAAiBC,GAAjB,CAAqB,MAAM,IAAIF,KAAJ,CAAU,EAAV,EAAcC,IAAd,CAAmB,CAAnB,CAA3B,CAAV;AACAF,QAAAA,KAAK,GAAG,EAAR;AACD,OAHD,MAGO,IAAIF,UAAU,KAAK,WAAnB,EAAgC;AACrCC,QAAAA,OAAO,GAAGE,KAAK,CAAC,EAAD,CAAL,CAAUC,IAAV,GAAiBC,GAAjB,CAAqB,MAAM,IAAIF,KAAJ,CAAU,EAAV,EAAcC,IAAd,CAAmB,CAAnB,CAA3B,CAAV;AACAF,QAAAA,KAAK,GAAG,EAAR;AACD,OAHM,MAGA;AACLD,QAAAA,OAAO,GAAGE,KAAK,CAAC,CAAD,CAAL,CAASC,IAAT,GAAgBC,GAAhB,CAAoB,MAAM,IAAIF,KAAJ,CAAU,CAAV,EAAaC,IAAb,CAAkB,CAAlB,CAA1B,CAAV;AACAF,QAAAA,KAAK,GAAG,EAAR;AACD;;AAED,WAAKI,QAAL,CAAc;AACZC,QAAAA,IAAI,EAAEN,OADM;AAEZC,QAAAA;AAFY,OAAd,EAGG,MAAM;AACP,aAAKM,WAAL;AACD,OALD;AAMD,KAvCkB;;AAAA,SAyGnBC,iBAzGmB,GAyGEC,MAAD,IAAY;AAC9B,UAAI,KAAKC,KAAL,CAAWC,MAAf,EAAuB;AACrB,YAAIC,YAAY,GAAG,KAAKF,KAAL,CAAWJ,IAAX,CAAgBG,MAAM,CAAC,CAAD,CAAtB,EAA2BA,MAAM,CAAC,CAAD,CAAjC,CAAnB,CADqB,CAErB;;AACA,YAAIG,YAAY,KAAK,GAArB,EAA0B;AACxB,eAAKP,QAAL,CAAc;AACZQ,YAAAA,IAAI,EAAE,IADM;AAEZF,YAAAA,MAAM,EAAE;AAFI,WAAd,EADwB,CAKxB;AACD,SAND,MAMO,IAAIC,YAAY,KAAK,CAArB,EAAwB;AAC7B,eAAKE,qBAAL,CAA2BL,MAA3B,EAD6B,CAE7B;AACD,SAHM,MAGA;AACL,cAAIM,QAAQ,GAAG,CAAC,GAAG,KAAKL,KAAL,CAAWJ,IAAf,CAAf;AACAS,UAAAA,QAAQ,CAACN,MAAM,CAAC,CAAD,CAAP,CAAR,CAAoBA,MAAM,CAAC,CAAD,CAA1B,IAAiCG,YAAY,GAAG,GAAhD;AACA,eAAKP,QAAL,CAAc;AAAEC,YAAAA,IAAI,EAAES;AAAR,WAAd;AACD;;AACD,YAAI,KAAKL,KAAL,CAAWT,KAAX,KAAqB,CAAzB,EAA4B;AAC1B,eAAKe,QAAL;AACD;AACF;AACF,KA/HkB;;AAAA,SAkInBF,qBAlImB,GAkIML,MAAD,IAAY;AAClC,UAAIM,QAAQ,GAAG,CAAC,GAAG,KAAKL,KAAL,CAAWJ,IAAf,CAAf;AACA,UAAIW,OAAO,GAAG,EAAd;AACAA,MAAAA,OAAO,CAACR,MAAD,CAAP,GAAkB,IAAlB;AACA,UAAIS,KAAK,GAAG,CAACT,MAAD,CAAZ;;AAEA,aAAOS,KAAK,CAACC,MAAN,GAAe,CAAtB,EAAyB;AACvB,YAAIC,OAAO,GAAGF,KAAK,CAACG,GAAN,EAAd;;AAEA,YAAIN,QAAQ,CAACK,OAAO,CAAC,CAAD,CAAR,CAAR,CAAqBA,OAAO,CAAC,CAAD,CAA5B,MAAqC,CAAzC,EAA4C;AAC1C;AACAL,UAAAA,QAAQ,CAACK,OAAO,CAAC,CAAD,CAAR,CAAR,CAAqBA,OAAO,CAAC,CAAD,CAA5B,IAAmC,IAAnC;AACD,SANsB,CAQvB;;;AACA,YAAIE,IAAI,GAAG,KAAKC,qBAAL,CAA2BH,OAAO,CAAC,CAAD,CAAlC,EAAuCA,OAAO,CAAC,CAAD,CAA9C,CAAX,CATuB,CAWvB;;AACA,YAAII,YAAY,GAAGF,IAAI,CAACG,MAAL,CAAYC,CAAC,IAAIX,QAAQ,CAACW,CAAC,CAAC,CAAD,CAAF,CAAR,CAAeA,CAAC,CAAC,CAAD,CAAhB,MAAyB,CAA1C,CAAnB;AACAF,QAAAA,YAAY,CAACG,OAAb,CAAqBC,EAAE,IAAI;AACzB,cAAIC,SAAS,GAAGd,QAAQ,CAACa,EAAE,CAAC,CAAD,CAAH,CAAR,CAAgBA,EAAE,CAAC,CAAD,CAAlB,CAAhB,CADyB,CAEzB;;AACAb,UAAAA,QAAQ,CAACa,EAAE,CAAC,CAAD,CAAH,CAAR,CAAgBA,EAAE,CAAC,CAAD,CAAlB,IAAyBC,SAAS,GAAG,GAArC;AACD,SAJD,EAbuB,CAmBvB;;AACA,YAAIC,cAAc,GAAGR,IAAI,CAACG,MAAL,CAAYC,CAAC,IAAIX,QAAQ,CAACW,CAAC,CAAC,CAAD,CAAF,CAAR,CAAeA,CAAC,CAAC,CAAD,CAAhB,MAAyB,CAA1C,CAArB;;AACA,aAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,cAAc,CAACX,MAAnC,EAA2CY,CAAC,EAA5C,EAAgD;AAC9C,cAAI,CAACd,OAAO,CAACa,cAAc,CAACC,CAAD,CAAf,CAAZ,EAAiC;AAC/Bb,YAAAA,KAAK,CAACc,IAAN,CAAWF,cAAc,CAACC,CAAD,CAAzB;AACAd,YAAAA,OAAO,CAACa,cAAc,CAACC,CAAD,CAAf,CAAP,GAA6B,IAA7B;AACD;AACF;AACF;;AACD,WAAK1B,QAAL,CAAc;AAAEC,QAAAA,IAAI,EAAES;AAAR,OAAd;AACD,KArKkB;;AAAA,SAuKnBkB,eAvKmB,GAuKD,CAACC,CAAD,EAAIzB,MAAJ,KAAe;AAC/B,UAAI,KAAKC,KAAL,CAAWC,MAAf,EAAuB;AACrB,YAAIV,KAAK,GAAG,KAAKS,KAAL,CAAWT,KAAvB;AACA,YAAIc,QAAQ,GAAG,CAAC,GAAG,KAAKL,KAAL,CAAWJ,IAAf,CAAf;AACA,YAAI6B,WAAW,GAAGpB,QAAQ,CAACN,MAAM,CAAC,CAAD,CAAP,CAAR,CAAoBA,MAAM,CAAC,CAAD,CAA1B,IAAiC,EAAnD,CAHqB,CAIrB;;AACA,YAAI0B,WAAW,CAACC,QAAZ,CAAqB,GAArB,CAAJ,EAA+B;AAC7BnC,UAAAA,KAAK;AACLc,UAAAA,QAAQ,CAACN,MAAM,CAAC,CAAD,CAAP,CAAR,CAAoBA,MAAM,CAAC,CAAD,CAA1B,IAAiC0B,WAAW,CAACE,KAAZ,CAAkB,CAAlB,EAAqB,CAArB,CAAjC,CAF6B,CAG7B;AACD,SAJD,MAIO;AACLpC,UAAAA,KAAK;AACLc,UAAAA,QAAQ,CAACN,MAAM,CAAC,CAAD,CAAP,CAAR,CAAoBA,MAAM,CAAC,CAAD,CAA1B,KAAkC,GAAlC;AACD;;AAED,aAAKJ,QAAL,CAAc;AACZC,UAAAA,IAAI,EAAES,QADM;AAEZd,UAAAA;AAFY,SAAd,EAGG,MAAM,KAAKe,QAAL,EAHT;AAKD;AACF,KA5LkB;;AAAA,SA+LnBA,QA/LmB,GA+LR,MAAM;AACf,UAAI,KAAKN,KAAL,CAAWT,KAAX,KAAqB,CAAzB,EAA4B;AAC1B,aAAK,IAAI8B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKrB,KAAL,CAAWJ,IAAX,CAAgBa,MAApC,EAA4CY,CAAC,EAA7C,EAAiD;AAC/C,eAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5B,KAAL,CAAWJ,IAAX,CAAgBa,MAApC,EAA4CmB,CAAC,EAA7C,EAAiD;AAC/C,gBAAIT,SAAS,GAAG,KAAKnB,KAAL,CAAWJ,IAAX,CAAgByB,CAAhB,EAAmBO,CAAnB,IAAwB,EAAxC;AACAC,YAAAA,OAAO,CAACC,GAAR,CAAYX,SAAZ;;AACA,gBAAI,EAAEA,SAAS,CAACO,QAAV,CAAmB,GAAnB,KAA2BP,SAAS,KAAK,IAA3C,CAAJ,EAAsD;AACpD,qBAAO,KAAP;AACD;AACF;AACF;;AACD,aAAKxB,QAAL,CAAc;AAAEM,UAAAA,MAAM,EAAE;AAAV,SAAd;AACA,eAAO,IAAP;AACD;AACF,KA7MkB;;AAAA,SAoNnB8B,WApNmB,GAoNL,MAAM;AAClB,UAAI,CAAC,KAAK/B,KAAL,CAAWG,IAAZ,IAAoB,CAAC,KAAKH,KAAL,CAAWC,MAApC,EAA4C;AAC1C,aAAKN,QAAL,CAAc;AAAEM,UAAAA,MAAM,EAAE;AAAV,SAAd;AACD;AACF,KAxNkB;;AAAA,SA0NnB+B,WA1NmB,GA0NJ3C,UAAD,IAAgB;AAC5B,WAAKM,QAAL,CAAc;AACZQ,QAAAA,IAAI,EAAE,KADM;AAEZF,QAAAA,MAAM,EAAE;AAFI,OAAd,EAGI,MAAM;AACR,aAAKb,cAAL,CAAoBC,UAApB;AACD,OALD,EAD4B,CAO5B;AACD,KAlOkB;;AAEjB,SAAKW,KAAL,GAAa;AACXJ,MAAAA,IAAI,EAAE,EADK;AAEXL,MAAAA,KAAK,EAAE,CAFI;AAGXY,MAAAA,IAAI,EAAE,KAHK;AAIXF,MAAAA,MAAM,EAAE;AAJG,KAAb;AAMD;;AAEDgC,EAAAA,iBAAiB,GAAG;AAClB,SAAK7C,cAAL,CAAoB,KAAKD,KAAL,CAAWE,UAA/B;AACD;;AAED6C,EAAAA,kBAAkB,CAACC,SAAD,EAAY;AAC5B,QAAIA,SAAS,CAAC9C,UAAV,KAAyB,KAAKF,KAAL,CAAWE,UAApC,IAAkD,KAAKW,KAAL,CAAWC,MAAX,KAAsB,KAA5E,EAAmF;AACjF,WAAKb,cAAL,CAAoB,KAAKD,KAAL,CAAWE,UAA/B;AACD;AACF;;AAuBDQ,EAAAA,WAAW,GAAG;AACZ,QAAIN,KAAK,GAAG,CAAZ;AACA,QAAIc,QAAQ,GAAG,CAAC,GAAG,KAAKL,KAAL,CAAWJ,IAAf,CAAf;;AAEA,WAAOL,KAAK,GAAG,KAAKS,KAAL,CAAWT,KAA1B,EAAiC;AAC/B,UAAI6C,CAAC,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB,KAAKvC,KAAL,CAAWJ,IAAX,CAAgBa,MAA3C,CAAR;AACA,UAAI+B,CAAC,GAAGH,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB,KAAKvC,KAAL,CAAWJ,IAAX,CAAgBa,MAA3C,CAAR;;AACA,UAAIJ,QAAQ,CAAC+B,CAAD,CAAR,CAAYI,CAAZ,MAAmB,CAAvB,EAA0B;AACxBnC,QAAAA,QAAQ,CAAC+B,CAAD,CAAR,CAAYI,CAAZ,IAAiB,GAAjB;AACAjD,QAAAA,KAAK;AACN;AACF;;AACD,SAAKI,QAAL,CAAc;AAAEC,MAAAA,IAAI,EAAES;AAAR,KAAd,EAAkC,MAAM,KAAKoC,gBAAL,EAAxC;AACD,GAvDqC,CAyDtC;;;AACAA,EAAAA,gBAAgB,GAAG;AACjB,QAAIpC,QAAQ,GAAG,CAAC,GAAG,KAAKL,KAAL,CAAWJ,IAAf,CAAf;;AACA,SAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,QAAQ,CAACI,MAA7B,EAAqCY,CAAC,EAAtC,EAA0C;AACxC,WAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvB,QAAQ,CAACI,MAA7B,EAAqCmB,CAAC,EAAtC,EAA0C;AACxC,YAAIvB,QAAQ,CAACgB,CAAD,CAAR,CAAYO,CAAZ,MAAmB,GAAvB,EAA4B;AAC1BvB,UAAAA,QAAQ,CAACgB,CAAD,CAAR,CAAYO,CAAZ,IAAiB,KAAKc,aAAL,CAAmBrB,CAAnB,EAAsBO,CAAtB,EAAyBvB,QAAzB,CAAjB;AACD;AACF;AACF;;AACD,SAAKV,QAAL,CAAc;AAAEC,MAAAA,IAAI,EAAES;AAAR,KAAd;AACD,GApEqC,CAsEtC;;;AACAqC,EAAAA,aAAa,CAACN,CAAD,EAAII,CAAJ,EAAOnC,QAAP,EAAiB;AAC5B,QAAIsC,SAAS,GAAG,CAAhB;AACA,QAAI/B,IAAI,GAAG,KAAKC,qBAAL,CAA2BuB,CAA3B,EAA8BI,CAA9B,CAAX;;AACA,SAAK,IAAInB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,IAAI,CAACH,MAAzB,EAAiCY,CAAC,EAAlC,EAAsC;AACpC,UAAIuB,EAAE,GAAGhC,IAAI,CAACS,CAAD,CAAJ,CAAQ,CAAR,CAAT;AACA,UAAIwB,EAAE,GAAGjC,IAAI,CAACS,CAAD,CAAJ,CAAQ,CAAR,CAAT;AACA,UAAItB,MAAM,GAAIM,QAAQ,CAACuC,EAAD,CAAR,CAAaC,EAAb,CAAd;;AACA,UAAI9C,MAAM,KAAK,GAAf,EAAoB;AAClB4C,QAAAA,SAAS;AACV;AACF;;AACD,WAAOA,SAAP;AACD,GAnFqC,CAqFtC;AACA;;;AACA9B,EAAAA,qBAAqB,CAACuB,CAAD,EAAII,CAAJ,EAAO;AAC1B,QAAIM,GAAG,GAAG,CACR,CAACV,CAAC,GAAG,CAAL,EAAQI,CAAC,GAAG,CAAZ,CADQ,EAER,CAACJ,CAAC,GAAG,CAAL,EAAQI,CAAR,CAFQ,EAGR,CAACJ,CAAC,GAAG,CAAL,EAAQI,CAAC,GAAG,CAAZ,CAHQ,EAIR,CAACJ,CAAD,EAAII,CAAC,GAAG,CAAR,CAJQ,EAKR,CAACJ,CAAD,EAAII,CAAC,GAAG,CAAR,CALQ,EAMR,CAACJ,CAAC,GAAG,CAAL,EAAQI,CAAC,GAAG,CAAZ,CANQ,EAOR,CAACJ,CAAC,GAAG,CAAL,EAAQI,CAAR,CAPQ,EAQR,CAACJ,CAAC,GAAG,CAAL,EAAQI,CAAC,GAAG,CAAZ,CARQ,CAAV;AAUA,WAAOM,GAAG,CAAC/B,MAAJ,CAAW,CAAChB,MAAD,EAASsB,CAAT,KAAe;AAC/B,UAAIuB,EAAE,GAAGE,GAAG,CAACzB,CAAD,CAAH,CAAO,CAAP,CAAT;AACA,UAAIwB,EAAE,GAAGC,GAAG,CAACzB,CAAD,CAAH,CAAO,CAAP,CAAT;AACA,aAAQuB,EAAE,IAAI,CAAN,IAAWC,EAAE,IAAI,CAAjB,IAAsBD,EAAE,GAAG,KAAK5C,KAAL,CAAWJ,IAAX,CAAgBa,MAA3C,IAAqDoC,EAAE,GAAG,KAAK7C,KAAL,CAAWJ,IAAX,CAAgBa,MAAlF;AACD,KAJM,CAAP;AAKD,GAvGqC,CAyGtC;;;AA4HAsC,EAAAA,MAAM,GAAG;AACP;AACA;AACA,UAAMC,QAAQ,GAAG,KAAKhD,KAAL,CAAWJ,IAAX,CAAgBF,GAAhB,CAAoB,CAACuD,GAAD,EAAM5B,CAAN,KAAY;AAC/C,aACE;AAAI,QAAA,GAAG,EAAE,QAAQA,CAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SACG4B,GAAG,CAACvD,GAAJ,CAAQ,CAACwD,GAAD,EAAMtB,CAAN,KAAY;AACnB,YAAIuB,QAAQ,GAAG,KAAf;AACA,YAAIC,OAAO,GAAG,KAAd;AACA,YAAIlD,YAAY,GAAG,KAAKF,KAAL,CAAWJ,IAAX,CAAgByB,CAAhB,EAAmBO,CAAnB,EAAsByB,QAAtB,EAAnB;AACAnD,QAAAA,YAAY,CAACwB,QAAb,CAAsB,GAAtB,IAA6ByB,QAAQ,GAAG,IAAxC,GAA+CA,QAAQ,GAAG,KAA1D;AACAjD,QAAAA,YAAY,CAACwB,QAAb,CAAsB,GAAtB,IAA6B0B,OAAO,GAAG,IAAvC,GAA8CA,OAAO,GAAG,KAAxD;AACA,eACE,oBAAC,MAAD;AACE,UAAA,GAAG,EAAE/B,CAAC,GAAG,GAAJ,GAAUO,CADjB;AAEE,UAAA,QAAQ,EAAEuB,QAFZ;AAGE,UAAA,IAAI,EAAEjD,YAAY,CAACoD,MAAb,CAAoB,CAApB,CAHR;AAIE,UAAA,OAAO,EAAEF,OAJX;AAKE,UAAA,IAAI,EAAE,KAAKpD,KAAL,CAAWG,IALnB;AAME,UAAA,MAAM,EAAE,CAACkB,CAAD,EAAIO,CAAJ,CANV;AAOE,UAAA,iBAAiB,EAAE,KAAK9B,iBAP1B;AAQE,UAAA,eAAe,EAAE,KAAKyB,eARxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UADF;AAWD,OAjBA,CADH,CADF;AAsBD,KAvBgB,CAAjB;AAyBA,WACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE,oBAAC,WAAD;AACE,MAAA,KAAK,EAAE,KAAKvB,KAAL,CAAWT,KADpB;AAEE,MAAA,MAAM,EAAE,KAAKS,KAAL,CAAWC,MAFrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADF,EAIE;AAAO,MAAA,WAAW,EAAC,GAAnB;AAAuB,MAAA,EAAE,EAAC,OAA1B;AAAkC,MAAA,YAAY,EAAE,KAAK8B,WAArD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACGiB,QADH,CADF,CAJF,EASG,KAAKhD,KAAL,CAAWG,IAAX,IAAmB,KAAKG,QAAL,EAAnB,GACC,oBAAC,WAAD;AACE,MAAA,UAAU,EAAE,KAAKN,KAAL,CAAWX,UADzB;AAEE,MAAA,OAAO,EAAE,KAAK2C,WAFhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADD,GAKK,IAdR,CADF;AAmBD;;AApRqC;;AAuRxC,eAAehD,SAAf","sourcesContent":["import React from 'react'\nimport Square from '../components/Square'\nimport GameInfoBar from '../components/GameInfoBar'\nimport NewGameMenu from '../components/NewGameMenu'\n\nclass GameBoard extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      grid: [],\n      mines: 0,\n      dead: false,\n      active: false\n    }\n  }\n\n  componentDidMount() {\n    this.determineBoard(this.props.difficulty)\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.difficulty !== this.props.difficulty && this.state.active === false) {\n      this.determineBoard(this.props.difficulty)\n    }\n  }\n\n  determineBoard = (difficulty) => {\n    let newGrid, mines;\n    if (difficulty === \"intermediate\") {\n      newGrid = Array(16).fill().map(() => new Array(16).fill(0))\n      mines = 40\n    } else if (difficulty === \"difficult\") {\n      newGrid = Array(22).fill().map(() => new Array(22).fill(0))\n      mines = 99\n    } else {\n      newGrid = Array(9).fill().map(() => new Array(9).fill(0))\n      mines = 10\n    }\n\n    this.setState({\n      grid: newGrid,\n      mines\n    }, () => {\n      this.randomMines()\n    })\n  }\n\n  randomMines() {\n    let mines = 0\n    let copyGrid = [...this.state.grid]\n\n    while (mines < this.state.mines) {\n      let x = Math.floor(Math.random() * this.state.grid.length)\n      let y = Math.floor(Math.random() * this.state.grid.length)\n      if (copyGrid[x][y] === 0) {\n        copyGrid[x][y] = 'b'\n        mines++\n      }\n    }\n    this.setState({ grid: copyGrid }, () => this.setNeighborCount())\n  }\n\n  //reassigns the values in the state grid to accuratly reflect the number of mines contained in neighboring tiles\n  setNeighborCount() {\n    let copyGrid = [...this.state.grid]\n    for (var i = 0; i < copyGrid.length; i++) {\n      for (var j = 0; j < copyGrid.length; j++) {\n        if (copyGrid[i][j] !== 'b') {\n          copyGrid[i][j] = this.neighborMines(i, j, copyGrid)\n        }\n      }\n    }\n    this.setState({ grid: copyGrid })\n  }\n\n  //checks- through a copy of the current state grid- the value of all neighboring tiles and returns # of mines\n  neighborMines(x, y, copyGrid) {\n    let bombCount = 0\n    let poss = this.generatePossibilities(x, y)\n    for (var i = 0; i < poss.length; i++) {\n      let xx = poss[i][0]\n      let yy = poss[i][1]\n      let coords = (copyGrid[xx][yy])\n      if (coords === 'b') {\n        bombCount++\n      }\n    }\n    return bombCount\n  }\n\n  //uses a 2d array of the 8 possible tiles around any given x,y coordinate and\n  //then filters out those which could not exist on currents state's board length\n  generatePossibilities(x, y) {\n    let all = [\n      [x - 1, y - 1],\n      [x - 1, y],\n      [x - 1, y + 1],\n      [x, y + 1],\n      [x, y - 1],\n      [x + 1, y - 1],\n      [x + 1, y],\n      [x + 1, y + 1]\n    ]\n    return all.filter((coords, i) => {\n      let xx = all[i][0]\n      let yy = all[i][1]\n      return (xx >= 0 && yy >= 0 && xx < this.state.grid.length && yy < this.state.grid.length)\n    })\n  }\n\n  //breadth first search to \"click\" all suitable 0 tiles and reveal all suitable # tiles\n  handleSquareClick = (coords) => {\n    if (this.state.active) {\n      let currentValue = this.state.grid[coords[0]][coords[1]]\n      // bomb click\n      if (currentValue === 'b') {\n        this.setState({\n          dead: true,\n          active: false\n        })\n        // empty square click\n      } else if (currentValue === 0) {\n        this.handleZeroSquareClick(coords)\n        // number square click\n      } else {\n        let copyGrid = [...this.state.grid]\n        copyGrid[coords[0]][coords[1]] = currentValue + \"*\"\n        this.setState({ grid: copyGrid })\n      }\n      if (this.state.mines === 0) {\n        this.winCheck()\n      }\n    }\n  }\n\n  //this whole method needs to be cleaned up a bit\n  handleZeroSquareClick = (coords) => {\n    let copyGrid = [...this.state.grid]\n    let visited = {}\n    visited[coords] = true\n    let queue = [coords]\n\n    while (queue.length > 0) {\n      let current = queue.pop()\n\n      if (copyGrid[current[0]][current[1]] === 0) {\n        // grid shows first character - need blank space\n        copyGrid[current[0]][current[1]] = ' *'\n      }\n\n      //grab all possibile neighboring tiles\n      let poss = this.generatePossibilities(current[0], current[1])\n\n      // filter possibilities for number tile and reveal them\n      let neighborNums = poss.filter(n => copyGrid[n[0]][n[1]] !== 0)\n      neighborNums.forEach(ss => {\n        let currValue = copyGrid[ss[0]][ss[1]]\n        // * is revealed\n        copyGrid[ss[0]][ss[1]] = currValue + \"*\"\n      })\n\n      //filter for suitable 0/blank tiles and visit them on search\n      let neighborBlanks = poss.filter(n => copyGrid[n[0]][n[1]] === 0)\n      for (let i = 0; i < neighborBlanks.length; i++) {\n        if (!visited[neighborBlanks[i]]) {\n          queue.push(neighborBlanks[i])\n          visited[neighborBlanks[i]] = true\n        }\n      }\n    }\n    this.setState({ grid: copyGrid })\n  }\n\n  handleFlagClick = (e, coords) => {\n    if (this.state.active) {\n      let mines = this.state.mines\n      let copyGrid = [...this.state.grid];\n      let stringValue = copyGrid[coords[0]][coords[1]] + '';\n      //remove flag\n      if (stringValue.includes('F')) {\n        mines++;\n        copyGrid[coords[0]][coords[1]] = stringValue.slice(0, 1)\n        //adding flag\n      } else {\n        mines--;\n        copyGrid[coords[0]][coords[1]] += 'F'\n      }\n\n      this.setState({\n        grid: copyGrid,\n        mines\n      }, () => this.winCheck()\n      )\n    }\n  }\n\n  //filter\n  winCheck = () => {\n    if (this.state.mines === 0) {\n      for (let i = 0; i < this.state.grid.length; i++) {\n        for (let j = 0; j < this.state.grid.length; j++) {\n          let currValue = this.state.grid[i][j] + ''\n          console.log(currValue)\n          if (!(currValue.includes('*') || currValue === 'bF')) {\n            return false\n          }\n        }\n      }\n      this.setState({ active: false })\n      return true\n    }\n  }\n\n  // winGame = () => {\n  //   this.setState({ active: false })\n  // }\n\n  // only starts timer\n  gameStarted = () => {\n    if (!this.state.dead && !this.state.active) {\n      this.setState({ active: true })\n    }\n  }\n\n  restartGame = (difficulty) => {\n    this.setState({\n      dead: false,\n      active: false,\n     }, () => {\n      this.determineBoard(difficulty)\n    })\n    //reset timer\n  }\n\n  render() {\n    //render the current board via passing in values from state grid to Square components and\n    //arranging them in a table\n    const gameGrid = this.state.grid.map((row, i) => {\n      return (\n        <tr key={\"row\" + i}>\n          {row.map((col, j) => {\n            let revealed = false;\n            let flagged = false;\n            let currentValue = this.state.grid[i][j].toString()\n            currentValue.includes('*') ? revealed = true : revealed = false\n            currentValue.includes('F') ? flagged = true : flagged = false\n            return (\n              <Square\n                key={i + \":\" + j}\n                revealed={revealed}\n                data={currentValue.charAt(0)}\n                flagged={flagged}\n                dead={this.state.dead}\n                coords={[i, j]}\n                handleSquareClick={this.handleSquareClick}\n                handleFlagClick={this.handleFlagClick} />\n            )\n          })}\n        </tr>\n      )\n    })\n\n    return (\n      <div>\n        <GameInfoBar\n          mines={this.state.mines}\n          active={this.state.active} />\n        <table cellSpacing=\"0\" id=\"table\" onMouseEnter={this.gameStarted} >\n          <tbody>\n            {gameGrid}\n          </tbody>\n        </table>\n        {this.state.dead || this.winCheck() ?\n          <NewGameMenu\n            difficulty={this.state.difficulty}\n            restart={this.restartGame}\n             />\n            : null}\n      </div>\n    )\n\n  }\n}\n\nexport default GameBoard;\n"]},"metadata":{},"sourceType":"module"}