{"ast":null,"code":"var _jsxFileName = \"/Users/clairemuller/Dev/ReactMineSweeper/src/containers/GameBoard.js\";\nimport React from 'react';\nimport Square from '../components/Square';\n\nclass GameBoard extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.determineBoard = difficulty => {\n      console.log(difficulty);\n\n      switch (difficulty) {\n        case 'intermediate':\n          this.setState({\n            grid: Array(16).fill().map(() => new Array(16).fill(0)),\n            mines: 40\n          });\n          break;\n\n        case 'difficult':\n          this.setState({\n            grid: Array(16).fill().map(() => new Array(30).fill(0)),\n            mines: 99\n          });\n          break;\n\n        default:\n          this.setState({\n            grid: Array(9).fill().map(() => new Array(9).fill(0)),\n            mines: 10\n          });\n      }\n    };\n\n    this.handleSquareClick = (e, coords) => {\n      let currentValue = this.state.grid[coords[0]][coords[1]];\n\n      if (currentValue === 'b') {\n        this.setState({\n          dead: true\n        });\n      } else if (currentValue === 0) {\n        this.handleZeroSquareClick(coords);\n      } else {\n        let copyGrid = [...this.state.grid];\n        copyGrid[coords[0]][coords[1]] = currentValue + \"*\";\n        this.setState({\n          grid: copyGrid\n        });\n      }\n    };\n\n    this.handleZeroSquareClick = coords => {\n      let copyGrid = [...this.state.grid];\n      let visited = {};\n      visited[coords] = true;\n      let queue = [coords];\n\n      while (queue.length > 0) {\n        let current = queue.pop();\n\n        if (copyGrid[current[0]][current[1]] === 0) {\n          copyGrid[current[0]][current[1]] = ' *';\n        } //grab all possibile neighboring tiles\n\n\n        let poss = this.generatePossibilities(current[0], current[1]); // filter possibilities for numbe tile and reveal them\n\n        let bordering = poss.filter(n => copyGrid[n[0]][n[1]] !== 0);\n        bordering.forEach(ss => {\n          let currValue = copyGrid[ss[0]][ss[1]]; // * is revealed\n\n          copyGrid[ss[0]][ss[1]] = currValue + \"*\";\n        }); //filter for suitable 0/blank tiles and visit them on search\n\n        let neighbors = poss.filter(n => copyGrid[n[0]][n[1]] === 0);\n\n        for (let i = 0; i < neighbors.length; i++) {\n          if (!visited[neighbors[i]]) {\n            queue.push(neighbors[i]);\n            visited[neighbors[i]] = true;\n          }\n        }\n      }\n\n      this.setState({\n        grid: copyGrid\n      });\n    };\n\n    this.handleFlagClick = (e, coords) => {\n      let copyGrid = [...this.state.grid];\n      let stringValue = copyGrid[coords[0]][coords[1]] + '';\n\n      if (stringValue.includes('F')) {\n        copyGrid[coords[0]][coords[1]] = stringValue.slice(0, 1);\n      } else {\n        copyGrid[coords[0]][coords[1]] += 'F';\n      }\n\n      this.setState({\n        grid: copyGrid\n      });\n    };\n\n    this.state = {\n      grid: Array(9).fill().map(() => new Array(9).fill(0)),\n      mines: 10,\n      dead: false\n    };\n  }\n\n  componentDidMount() {\n    this.determineBoard(this.props.difficulty);\n    this.randomMines();\n    this.setNeighborCount();\n  }\n\n  componentDidUpdate(prevProps) {// if (prevProps.difficulty !== this.props.difficulty) {\n    //   this.determineBoard(this.props.difficulty)\n    // }\n    // this.randomMines()\n    // this.setNeighborCount()\n  }\n\n  randomMines() {\n    let mines = 0;\n    let copyGrid = [...this.state.grid];\n\n    while (mines < this.state.mines) {\n      let x = Math.floor(Math.random() * this.state.grid.length);\n      let y = Math.floor(Math.random() * this.state.grid.length);\n\n      if (copyGrid[x][y] === 0) {\n        copyGrid[x][y] = 'b';\n        mines++;\n      }\n    }\n\n    this.setState({\n      grid: copyGrid\n    });\n  } //uses a 2d array of the 8 possible tiles around any given x,y coordinate and\n  //then filters out those which could not exist on currents state's board length\n\n\n  generatePossibilities(x, y) {\n    let all = [[x - 1, y - 1], [x - 1, y], [x - 1, y + 1], [x, y + 1], [x, y - 1], [x + 1, y - 1], [x + 1, y], [x + 1, y + 1]];\n    return all.filter((coords, i) => {\n      let xx = all[i][0];\n      let yy = all[i][1];\n      return xx >= 0 && yy >= 0 && xx < this.state.grid.length && yy < this.state.grid.length;\n    });\n  } //checks- through a copy of the current state grid- the value of all neighboring tiles and returns # of mines\n\n\n  neighborMines(x, y, copyGrid) {\n    let bombCount = 0;\n    let poss = this.generatePossibilities(x, y);\n\n    for (var i = 0; i < poss.length; i++) {\n      let xx = poss[i][0];\n      let yy = poss[i][1];\n      let coords = copyGrid[xx][yy];\n\n      if (coords === 'b') {\n        bombCount++;\n      }\n    }\n\n    return bombCount;\n  } //reassigns the values in the state grid to accuratly reflect the number of mines contained in neighboring tiles\n\n\n  setNeighborCount() {\n    let copyGrid = [...this.state.grid];\n    let updateGrid = [...this.state.grid];\n\n    for (var i = 0; i < copyGrid.length; i++) {\n      for (var j = 0; j < copyGrid.length; j++) {\n        if (copyGrid[i][j] !== 'b') {\n          updateGrid[i][j] = this.neighborMines(i, j, copyGrid);\n        }\n      }\n    }\n\n    this.setState({\n      grid: updateGrid\n    });\n  } //breadth first search to \"click\" all suitable 0 tiles and reveal all suitable # tiles\n\n\n  render() {\n    const style = {\n      textAlign: \"center\",\n      tableLayout: 'fixed' //render the current borad via passing in values from state grid to Square components and\n      //arranging them in a table\n\n    };\n    const gameGrid = this.state.grid.map((row, i) => {\n      return React.createElement(\"tr\", {\n        key: \"row\" + i,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 190\n        },\n        __self: this\n      }, row.map((col, j) => {\n        let revealed = false;\n        let flagged = false;\n        let currentValue = this.state.grid[i][j].toString();\n        currentValue.includes('*') ? revealed = true : revealed = false;\n        currentValue.includes('F') ? flagged = true : flagged = false;\n        return React.createElement(Square, {\n          key: i + \":\" + j,\n          revealed: revealed,\n          data: currentValue.charAt(0),\n          flagged: flagged,\n          dead: this.state.dead,\n          coords: [i, j],\n          handleSquareClick: this.handleSquareClick,\n          handleFlagClick: this.handleFlagClick,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 198\n          },\n          __self: this\n        });\n      }));\n    });\n    return React.createElement(\"table\", {\n      cellSpacing: \"0\",\n      id: \"table\",\n      style: style,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 214\n      },\n      __self: this\n    }, React.createElement(\"tbody\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 215\n      },\n      __self: this\n    }, gameGrid));\n  }\n\n}\n\nexport default GameBoard;","map":{"version":3,"sources":["/Users/clairemuller/Dev/ReactMineSweeper/src/containers/GameBoard.js"],"names":["React","Square","GameBoard","Component","constructor","props","determineBoard","difficulty","console","log","setState","grid","Array","fill","map","mines","handleSquareClick","e","coords","currentValue","state","dead","handleZeroSquareClick","copyGrid","visited","queue","length","current","pop","poss","generatePossibilities","bordering","filter","n","forEach","ss","currValue","neighbors","i","push","handleFlagClick","stringValue","includes","slice","componentDidMount","randomMines","setNeighborCount","componentDidUpdate","prevProps","x","Math","floor","random","y","all","xx","yy","neighborMines","bombCount","updateGrid","j","render","style","textAlign","tableLayout","gameGrid","row","col","revealed","flagged","toString","charAt"],"mappings":"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","sourcesContent":["import React from 'react'\nimport Square from '../components/Square'\n\nclass GameBoard extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      grid: Array(9).fill().map(() => new Array(9).fill(0)),\n      mines: 10,\n      dead: false\n    }\n  }\n\n  componentDidMount() {\n    this.determineBoard(this.props.difficulty)\n    this.randomMines()\n    this.setNeighborCount()\n  }\n\n  componentDidUpdate(prevProps) {\n    // if (prevProps.difficulty !== this.props.difficulty) {\n    //   this.determineBoard(this.props.difficulty)\n    // }\n    // this.randomMines()\n    // this.setNeighborCount()\n  }\n\n  determineBoard = (difficulty) => {\n    console.log(difficulty);\n    switch (difficulty) {\n      case 'intermediate':\n        this.setState({\n          grid: Array(16).fill().map(() => new Array(16).fill(0)),\n          mines: 40\n        })\n        break;\n      case 'difficult':\n        this.setState({\n          grid: Array(16).fill().map(() => new Array(30).fill(0)),\n          mines: 99\n        })\n        break;\n      default:\n        this.setState({\n          grid: Array(9).fill().map(() => new Array(9).fill(0)),\n          mines: 10\n        })\n    }\n  }\n\n  randomMines() {\n    let mines = 0\n    let copyGrid = [...this.state.grid]\n\n    while (mines < this.state.mines) {\n      let x = Math.floor(Math.random() * this.state.grid.length)\n      let y = Math.floor(Math.random() * this.state.grid.length)\n      if (copyGrid[x][y] === 0) {\n        copyGrid[x][y] = 'b'\n        mines++\n      }\n    }\n    this.setState({ grid: copyGrid })\n  }\n\n  //uses a 2d array of the 8 possible tiles around any given x,y coordinate and\n  //then filters out those which could not exist on currents state's board length\n  generatePossibilities(x, y) {\n    let all = [\n      [x - 1, y - 1],\n      [x - 1, y],\n      [x - 1, y + 1],\n      [x, y + 1],\n      [x, y - 1],\n      [x + 1, y - 1],\n      [x + 1, y],\n      [x + 1, y + 1]\n    ]\n    return all.filter((coords, i) => {\n      let xx = all[i][0]\n      let yy = all[i][1]\n      return (xx >= 0 && yy >= 0 && xx < this.state.grid.length && yy < this.state.grid.length)\n    })\n  }\n\n  //checks- through a copy of the current state grid- the value of all neighboring tiles and returns # of mines\n  neighborMines(x, y, copyGrid) {\n    let bombCount = 0\n    let poss = this.generatePossibilities(x, y)\n    for (var i = 0; i < poss.length; i++) {\n      let xx = poss[i][0]\n      let yy = poss[i][1]\n      let coords = (copyGrid[xx][yy])\n      if (coords === 'b') {\n        bombCount++\n      }\n    }\n    return bombCount\n  }\n\n  //reassigns the values in the state grid to accuratly reflect the number of mines contained in neighboring tiles\n  setNeighborCount() {\n    let copyGrid = [...this.state.grid]\n    let updateGrid = [...this.state.grid]\n    for (var i = 0; i < copyGrid.length; i++) {\n      for (var j = 0; j < copyGrid.length; j++) {\n        if (copyGrid[i][j] !== 'b') {\n          updateGrid[i][j] = this.neighborMines(i, j, copyGrid)\n        }\n      }\n    }\n    this.setState({ grid: updateGrid })\n  }\n\n  //breadth first search to \"click\" all suitable 0 tiles and reveal all suitable # tiles\n\n  handleSquareClick = (e, coords) => {\n    let currentValue = this.state.grid[coords[0]][coords[1]]\n    if (currentValue === 'b') {\n      this.setState({ dead: true })\n    } else if (currentValue === 0) {\n      this.handleZeroSquareClick(coords)\n    } else {\n      let copyGrid = [...this.state.grid]\n      copyGrid[coords[0]][coords[1]] = currentValue + \"*\"\n      this.setState({ grid: copyGrid })\n    }\n  }\n\n  //this whole method needs to be cleaned up a bit\n  handleZeroSquareClick = (coords) => {\n    let copyGrid = [...this.state.grid]\n    let visited = {}\n    visited[coords] = true\n    let queue = [coords]\n\n    while (queue.length > 0) {\n      let current = queue.pop()\n\n      if (copyGrid[current[0]][current[1]] === 0) {\n        copyGrid[current[0]][current[1]] = ' *'\n      }\n\n      //grab all possibile neighboring tiles\n      let poss = this.generatePossibilities(current[0], current[1])\n\n      // filter possibilities for numbe tile and reveal them\n      let bordering = poss.filter(n => copyGrid[n[0]][n[1]] !== 0)\n\n      bordering.forEach(ss => {\n        let currValue = copyGrid[ss[0]][ss[1]]\n        // * is revealed\n        copyGrid[ss[0]][ss[1]] = currValue + \"*\"\n      })\n\n      //filter for suitable 0/blank tiles and visit them on search\n      let neighbors = poss.filter(n => copyGrid[n[0]][n[1]] === 0)\n      for (let i = 0; i < neighbors.length; i++) {\n        if (!visited[neighbors[i]]) {\n          queue.push(neighbors[i])\n          visited[neighbors[i]] = true\n        }\n      }\n    }\n\n    this.setState({ grid: copyGrid })\n  }\n\n  handleFlagClick = (e, coords) => {\n    let copyGrid = [...this.state.grid];\n    let stringValue = copyGrid[coords[0]][coords[1]] + '';\n    if (stringValue.includes('F')) {\n      copyGrid[coords[0]][coords[1]] = stringValue.slice(0, 1)\n    } else {\n      copyGrid[coords[0]][coords[1]] += 'F'\n    }\n    this.setState({ grid: copyGrid })\n  }\n\n  render() {\n    const style = {\n      textAlign: \"center\",\n      tableLayout: 'fixed',\n    }\n\n    //render the current borad via passing in values from state grid to Square components and\n    //arranging them in a table\n    const gameGrid = this.state.grid.map((row, i) => {\n      return (\n        <tr key={\"row\" + i}>\n          {row.map((col, j) => {\n            let revealed = false;\n            let flagged = false;\n            let currentValue = this.state.grid[i][j].toString()\n            currentValue.includes('*') ? revealed = true : revealed = false\n            currentValue.includes('F') ? flagged = true : flagged = false\n            return (\n              <Square\n                key={i + \":\" + j}\n                revealed={revealed}\n                data={currentValue.charAt(0)}\n                flagged={flagged}\n                dead={this.state.dead}\n                coords={[i, j]}\n                handleSquareClick={this.handleSquareClick}\n                handleFlagClick={this.handleFlagClick} />\n            )\n          })}\n        </tr>\n      )\n    })\n\n    return (\n      <table cellSpacing=\"0\" id=\"table\" style={style}>\n        <tbody>\n          {gameGrid}\n        </tbody>\n      </table>\n\n    )\n  }\n}\n\nexport default GameBoard;\n"]},"metadata":{},"sourceType":"module"}